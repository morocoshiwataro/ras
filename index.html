<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>荒野の王（WK）計算フォーム</title>
  <style>
    :root { --bd:#ddd; --bg:#fafafa; --warn:#c00; --ok:#0a7; }
    body { font-family: system-ui, -apple-system, "Segoe UI", "Noto Sans JP", sans-serif; max-width: 980px; margin: 20px auto; padding: 0 14px; line-height: 1.45; }
    h1 { font-size: 20px; margin: 0 0 10px; }
    h2 { font-size: 16px; margin: 22px 0 10px; }
    .card { border: 1px solid var(--bd); border-radius: 12px; padding: 14px; background: white; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 820px){ .row { grid-template-columns: 1fr; } }
    label { display: block; font-weight: 650; margin-bottom: 6px; }
    input, select { width: 100%; padding: 10px; border: 1px solid var(--bd); border-radius: 10px; font-size: 14px; background: white; }
    .muted { color:#666; font-size: 12px; }
    .result { margin-top: 12px; border-top: 1px dashed var(--bd); padding-top: 12px; }
    .kpi { display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; }
    @media (max-width: 820px){ .kpi { grid-template-columns: 1fr; } }
    .k { border: 1px solid var(--bd); border-radius: 12px; padding: 12px; background: var(--bg); }
    .k b { font-size: 16px; display:block; margin-top: 4px; font-variant-numeric: tabular-nums; }
    .warn { color: var(--warn); font-weight: 800; }
    .hidden { display:none; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid var(--bd); padding: 8px; text-align: right; font-variant-numeric: tabular-nums; }
    th:first-child, td:first-child { text-align: left; }
    .foot { margin-top: 14px; font-size: 12px; color:#666; }
    .hr { height: 1px; background: var(--bd); margin: 14px 0; }
    .pill { display:inline-block; padding: 2px 8px; border:1px solid var(--bd); border-radius: 999px; font-size: 12px; background: var(--bg); }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid var(--bd); background: var(--bg); cursor: pointer; }
  </style>
</head>
<body>
  <h1>荒野の王（WK）計算フォーム</h1>

  <div class="card">
    <div class="row">
      <div>
        <label>① 病院容量（現在の深部容量）<span class="pill">必須</span></label>
        <input id="hospitalCap" type="number" min="0" step="1" placeholder="例：132750" />
        <div class="muted">単位：人（収容できる最大数）</div>
      </div>
      <div>
        <label>② アフターショック率 <span class="pill">必須</span></label>
        <input id="aftershockRate" type="number" min="0" step="0.01" placeholder="例：14" />
        <div class="muted">入力は「%の数値」（例：14% → 14）</div>
      </div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <div>
        <label>目的 <span class="pill">必須</span></label>
        <select id="mode">
          <option value="A">A：兵士をたくさん増やしたい（安全に突撃できる最大兵士数→内訳入力）</option>
          <option value="B">B：ポイントから逆算したい（目標実ポイント→必要突撃人数）</option>
        </select>
      </div>
      <div id="targetWrap" class="hidden">
        <label>③ ほしい実ポイント<span class="pill">必須（Bのみ）</span></label>
        <input id="targetPoints" type="number" min="0" step="1" placeholder="例：50525" />
        <div class="muted">刻み制限なし（整数で入力）</div>
      </div>
    </div>

    <!-- A -->
    <div id="sectionA" class="result">
      <h2>A：安全最大人数 → 兵士ランク内訳 → 合計ポイント（実ポイント）</h2>

      <div class="kpi">
        <div class="k">
          安全に突撃できる最大兵士数（推奨上限）
          <b id="aMaxSafe">-</b>
          <div class="muted">式：① ÷（0.7 + ②×0.003）</div>
        </div>
        <div class="k">
          入力した突撃人数 合計
          <b id="aTotalSoldiers">-</b>
        </div>
        <div class="k">
          合計ポイント（実ポイント）
          <b id="aTotalPoints">-</b>
          <div class="muted">④（兵士ランクごとのポイント）×人数 の合計</div>
        </div>
      </div>

      <div style="margin-top:12px;" class="muted">
        ※各ランクの突撃人数を入力してください（自動で合計ポイントを計算します）
      </div>

      <div style="margin-top:8px; overflow:auto;">
        <table>
          <thead>
            <tr>
              <th>兵士ランク</th>
              <th>突撃人数</th>
              <th>ポイント小計（実ポイント）</th>
            </tr>
          </thead>
          <tbody id="aTableBody"></tbody>
        </table>
      </div>

      <div id="aWarn" class="warn" style="margin-top:10px;"></div>
    </div>

    <!-- B -->
    <div id="sectionB" class="result hidden">
      <h2>B：目標実ポイント →（死亡数ポイント増分で埋める前提）メイン／サブの突撃人数</h2>

      <div class="row">
        <div>
          <label>現在獲得している実ポイント<span class="pill">必須</span></label>
          <input id="currentRealPoints" type="number" min="0" step="1" placeholder="例：12000" />
          <div class="muted">死亡数ポイント以外の入手分も全部含めた「現在の合計」</div>
        </div>
        <div>
          <label>現在の死亡数ポイント（累計）<span class="pill">必須</span></label>
          <input id="currentDeathPoints" type="number" min="0" step="1" placeholder="例：200000" />
          <div class="muted">死亡数ポイントで今どこまで到達しているか（累計値）</div>
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <div>
          <label>メインで突撃させる兵士ランク</label>
          <select id="mainRank"></select>
        </div>
        <div>
          <label>不足実ポイント（③−現在実ポイント）</label>
          <div class="k" style="margin-top:6px;">
            不足実ポイント
            <b id="bNeedPoints">-</b>
            <div class="muted">この不足分を「死亡数ポイント増分」で埋める前提で必要人数を逆算します</div>
          </div>
        </div>
      </div>

      <div class="kpi" style="margin-top:12px;">
        <div class="k">
          結論：メイン突撃人数
          <b id="bMainSoldiers">-</b>
        </div>
        <div class="k">
          結論：サブ突撃人数
          <b id="bSubSoldiers">0</b>
          <div class="muted">イレギュラー未使用の場合は0</div>
        </div>
        <div class="k">
          合計突撃人数（メイン+サブ）
          <b id="bTotalSoldiers">-</b>
        </div>
      </div>

      <div id="bWarn" class="warn" style="margin-top:10px;"></div>

      <div class="hr"></div>

      <button id="toggleIrregular" type="button">兵士が1種類では足りない場合（サブを使う）</button>

      <!-- Irregular -->
      <div id="irregularBox" class="card hidden" style="margin-top:14px;">
        <h2>イレギュラー：兵士を2種類で突撃する</h2>

        <div class="row">
          <div>
            <label>サブで突撃させる兵士ランク</label>
            <select id="subRank"></select>
          </div>
          <div>
            <label>⑥ メインで突撃させる兵士数（入力）</label>
            <input id="mainCountManual" type="number" min="0" step="1" placeholder="例：20000" />
            <div class="muted">入力すると自動でサブ必要人数を再計算します</div>
          </div>
        </div>

        <div class="kpi" style="margin-top:12px;">
          <div class="k">
            結論：メイン突撃人数
            <b id="iMainConclusion">-</b>
          </div>
          <div class="k">
            結論：サブ突撃人数
            <b id="iSubConclusion">-</b>
          </div>
          <div class="k">
            参考：サブ必要人数（算出）
            <b id="iSubNeed">-</b>
            <div class="muted">同じ値（表示名だけ）</div>
          </div>
        </div>

        <div id="iWarn" class="warn" style="margin-top:10px;"></div>

        <div class="foot">
          ※内部計算：不足実ポイント →「現在の死亡数ポイント」から到達増分で埋めるための必要人数を逆算します。<br/>
          すでに到達している死亡数ポイント分は差し引かれます（=増分だけ必要）。
        </div>
      </div>
    </div>

    <div class="hr"></div>

    <div class="foot">
      <b>利用条件</b><br/>
      本ページは、閲覧者が個人的に計算を行う目的に限り利用できます。<br/>
      本ページの計算内容・ロジック・数式・ソースコード等の転載は禁止での転載・流用・再配布・二次利用（別サイト/アプリ等への組み込みを含む）を禁止します。
    </div>
  </div>

<script>
(() => {
  // ④ 兵士ランクごとのポイント（=死亡数ポイント増分を作るための換算値として使う）
  const RANK_POINTS = {
    "T6": 20,
    "T7": 25,
    "T8": 33,
    "T9": 45,
    "T10": 60,
    "T11": 80,
    "T12": 100,
    "T13": 125,
  };

  // ⑤ 到達表（累計死亡数ポイント → 加算されるポイント）
  // 「到達したら加算される」方式（例：40000到達なら 100+150+200）
  const MILESTONES = [
    { deathPoints: 10000, addPoints: 100 },
    { deathPoints: 20000, addPoints: 150 },
    { deathPoints: 40000, addPoints: 200 },
    { deathPoints: 100000, addPoints: 250 },
    { deathPoints: 200000, addPoints: 300 },
    { deathPoints: 300000, addPoints: 350 },
    { deathPoints: 400000, addPoints: 400 },
    { deathPoints: 600000, addPoints: 450 },
    { deathPoints: 800000, addPoints: 500 },
    { deathPoints: 1000000, addPoints: 600 },
  ];
  const AFTER_1M_STEP = 500000;
  const AFTER_1M_ADD = 200;

  const $ = (id) => document.getElementById(id);

  function num(v, fallback = 0) {
    const n = Number(v);
    return Number.isFinite(n) ? n : fallback;
  }
  function fmt(n, digits=0) {
    if (!Number.isFinite(n)) return "-";
    return n.toLocaleString("ja-JP", { maximumFractionDigits: digits });
  }
  function ceil(n) {
    if (!Number.isFinite(n)) return NaN;
    return Math.ceil(n);
  }

  // 係数（0.7＋②×0.003）
  function factorFromRate(aftershockRatePercent) {
    return 0.7 + (aftershockRatePercent * 0.003);
  }

  // Aの推奨上限：①÷（0.7＋②×0.003）
  function calcMaxSafe(hospitalCap, aftershockRatePercent) {
    const factor = factorFromRate(aftershockRatePercent);
    if (!Number.isFinite(factor) || factor <= 0) return NaN;
    return hospitalCap / factor;
  }

  // 累計死亡数ポイント(deathPoints)に対して、到達で加算されるポイント（=実ポイントではない / ただしBの死亡数分の増分計算に使う）
  function pointsFromDeathPoints(deathPoints) {
    let p = 0;
    for (const m of MILESTONES) {
      if (deathPoints >= m.deathPoints) p += m.addPoints;
    }
    if (deathPoints > 1000000) {
      const extra = deathPoints - 1000000;
      const blocks = Math.floor(extra / AFTER_1M_STEP); // 50万ごと
      p += blocks * AFTER_1M_ADD;
    }
    return p;
  }

  // 「現在の死亡数ポイント」からスタートして、追加でneedPoints分のポイントを稼ぐために必要な最小の累計死亡数ポイントを返す
  function minDeathPointsFromCurrentForAdditionalPoints(currentDeathPoints, needAdditionalPoints) {
    if (needAdditionalPoints <= 0) return currentDeathPoints;

    const base = Math.max(0, Math.floor(currentDeathPoints));
    const basePoints = pointsFromDeathPoints(base);

    // まず既知の閾値候補（ベースより上だけ見る）
    const candidates = MILESTONES
      .map(m => m.deathPoints)
      .filter(dp => dp >= base)
      .sort((a,b)=>a-b);

    // ベース自体が閾値未満でも、pointsFromDeathPoints(base)は正しく算出済みなのでOK
    for (const dp of candidates) {
      const gain = pointsFromDeathPoints(dp) - basePoints;
      if (gain >= needAdditionalPoints) return dp;
    }

    // 100万以降：50万ごとに+200（閾値候補を段階的に伸ばす）
    let dp = Math.max(base, 1000000);
    while ((pointsFromDeathPoints(dp) - basePoints) < needAdditionalPoints) {
      dp += AFTER_1M_STEP;
      if (dp > 50000000) break; // 念のため
    }
    return dp;
  }

  // UI: ランク選択肢
  function fillRankSelect(sel) {
    sel.innerHTML = "";
    for (const r of Object.keys(RANK_POINTS)) {
      const opt = document.createElement("option");
      opt.value = r;
      opt.textContent = `${r}`;
      sel.appendChild(opt);
    }
  }

  // UI: Aのテーブル作成（1人あたりポイント列なし）
  function buildATable() {
    const body = $("aTableBody");
    body.innerHTML = "";

    for (const r of Object.keys(RANK_POINTS)) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r}</td>
        <td>
          <input data-rank="${r}" class="aCount" type="number" min="0" step="1"
                 placeholder="0" style="text-align:right;">
        </td>
        <td id="sub_${r}">0</td>
      `;
      body.appendChild(tr);
    }

    body.querySelectorAll(".aCount").forEach(inp => {
      inp.addEventListener("input", updateA);
    });
  }

  function updateMode() {
    const mode = $("mode").value;
    const isA = mode === "A";
    $("sectionA").classList.toggle("hidden", !isA);
    $("sectionB").classList.toggle("hidden", isA);
    $("targetWrap").classList.toggle("hidden", isA);

    updateA();
    updateBAll();
  }

  // A更新（表示は実ポイント）
  function updateA() {
    const cap = num($("hospitalCap").value, NaN);
    const rate = num($("aftershockRate").value, NaN);

    const maxSafeRaw = calcMaxSafe(cap, rate);
    const maxSafe = ceil(maxSafeRaw);

    let totalSoldiers = 0;
    let totalPoints = 0;

    document.querySelectorAll(".aCount").forEach(inp => {
      const r = inp.dataset.rank;
      const c = Math.max(0, Math.floor(num(inp.value, 0)));
      totalSoldiers += c;
      const sub = c * RANK_POINTS[r];
      totalPoints += sub;
      $("sub_" + r).textContent = fmt(sub);
    });

    $("aMaxSafe").textContent = Number.isFinite(maxSafe) ? fmt(maxSafe) : "-";
    $("aTotalSoldiers").textContent = fmt(totalSoldiers);
    $("aTotalPoints").textContent = fmt(totalPoints);

    const warn = [];
    if (Number.isFinite(maxSafe) && totalSoldiers > maxSafe) {
      warn.push(`最大兵士数（推奨上限）を超えています：${fmt(totalSoldiers)} > ${fmt(maxSafe)}`);
    }
    if (Number.isFinite(cap) && totalSoldiers > cap) {
      warn.push(`病院容量（①）を超えています：${fmt(totalSoldiers)} > ${fmt(cap)}`);
    }
    $("aWarn").textContent = warn.join(" / ");
  }

  // B：内部保持（表示はしない）
  let lastNeedDeathDelta = 0;  // 追加で必要な「死亡数ポイント（増分）」= newDP - currentDP

  function updateBCoreOrIrregular() {
    const cap = num($("hospitalCap").value, NaN);
    const rate = num($("aftershockRate").value, NaN);
    const factor = factorFromRate(rate);

    const target = num($("targetPoints").value, NaN);
    const curReal = num($("currentRealPoints").value, NaN);
    const curDeath = num($("currentDeathPoints").value, NaN);

    // 入力不足
    if (!Number.isFinite(target) || target < 0 || !Number.isFinite(curReal) || curReal < 0 || !Number.isFinite(curDeath) || curDeath < 0) {
      $("bNeedPoints").textContent = "-";
      $("bMainSoldiers").textContent = "-";
      $("bSubSoldiers").textContent = "0";
      $("bTotalSoldiers").textContent = "-";
      $("bWarn").textContent = "";
      lastNeedDeathDelta = 0;
      // イレギュラー欄もリセット
      $("iMainConclusion").textContent = "-";
      $("iSubConclusion").textContent = "-";
      $("iSubNeed").textContent = "-";
      $("iWarn").textContent = "";
      return;
    }

    // 不足実ポイント（ここは“実ポイント”の世界）
    const needRealPoints = Math.max(0, target - curReal);
    $("bNeedPoints").textContent = fmt(needRealPoints);

    // 不足実ポイントを「死亡数ポイント到達による加算」で埋めるための、必要な累計死亡数ポイントを逆算（現在死亡数ポイントからの増分で考える）
    const newDeathPoints = minDeathPointsFromCurrentForAdditionalPoints(curDeath, needRealPoints);
    const deltaDeathPoints = Math.max(0, newDeathPoints - Math.floor(curDeath));
    lastNeedDeathDelta = deltaDeathPoints;

    const mainRank = $("mainRank").value;
    const mainPer = RANK_POINTS[mainRank];

    const irregularOn = !$("irregularBox").classList.contains("hidden");

    if (!irregularOn) {
      // メインのみ
      const mainNeed = mainPer > 0 ? Math.ceil(deltaDeathPoints / mainPer) : NaN;

      $("bMainSoldiers").textContent = Number.isFinite(mainNeed) ? fmt(mainNeed) : "-";
      $("bSubSoldiers").textContent = "0";
      $("bTotalSoldiers").textContent = Number.isFinite(mainNeed) ? fmt(mainNeed) : "-";

      // 警告条件（指定）：人数×factor > 病院容量
      const warn = [];
      if (Number.isFinite(cap) && Number.isFinite(mainNeed) && Number.isFinite(factor) && (mainNeed * factor) > cap) {
        warn.push("病院容量を超えます");
      }
      $("bWarn").textContent = warn.join(" / ");
    } else {
      // イレギュラーON → サブ計算
      updateIrregular();
    }
  }

  function updateIrregular() {
    const cap = num($("hospitalCap").value, NaN);
    const rate = num($("aftershockRate").value, NaN);
    const factor = factorFromRate(rate);

    const mainRank = $("mainRank").value;
    const subRank = $("subRank").value;

    const mainPer = RANK_POINTS[mainRank];
    const subPer = RANK_POINTS[subRank];

    const mainCount = Math.max(0, Math.floor(num($("mainCountManual").value, NaN)));
    if (!Number.isFinite(mainCount)) {
      $("iMainConclusion").textContent = "-";
      $("iSubConclusion").textContent = "-";
      $("iSubNeed").textContent = "-";
      $("iWarn").textContent = "⑥ メインで突撃させる兵士数を入力してください。";

      $("bMainSoldiers").textContent = "-";
      $("bSubSoldiers").textContent = "-";
      $("bTotalSoldiers").textContent = "-";
      $("bWarn").textContent = "";
      return;
    }

    // 残り死亡数ポイント増分をサブで埋める
    const remain = Math.max(0, lastNeedDeathDelta - (mainCount * mainPer));
    const subNeed = subPer > 0 ? Math.ceil(remain / subPer) : NaN;
    const total = Number.isFinite(subNeed) ? (mainCount + subNeed) : NaN;

    $("iMainConclusion").textContent = fmt(mainCount);
    $("iSubConclusion").textContent = Number.isFinite(subNeed) ? fmt(subNeed) : "-";
    $("iSubNeed").textContent = Number.isFinite(subNeed) ? fmt(subNeed) : "-";

    // Bの結論に反映
    $("bMainSoldiers").textContent = fmt(mainCount);
    $("bSubSoldiers").textContent = Number.isFinite(subNeed) ? fmt(subNeed) : "-";
    $("bTotalSoldiers").textContent = Number.isFinite(total) ? fmt(total) : "-";

    // 警告条件（指定）：（合計人数）×factor > 病院容量
    const warn = [];
    if (Number.isFinite(cap) && Number.isFinite(total) && Number.isFinite(factor) && (total * factor) > cap) {
      warn.push("病院容量を超えます");
    }
    $("iWarn").textContent = warn.join(" / ");
    $("bWarn").textContent = warn.join(" / ");
  }

  function updateBAll() {
    updateBCoreOrIrregular();
  }

  // 初期化
  fillRankSelect($("mainRank"));
  fillRankSelect($("subRank"));
  buildATable();
  updateMode();
  updateA();
  updateBAll();

  // 共通入力：即反映
  $("hospitalCap").addEventListener("input", () => { updateA(); updateBAll(); });
  $("aftershockRate").addEventListener("input", () => { updateA(); updateBAll(); });

  // モード切替
  $("mode").addEventListener("change", updateMode);

  // B入力：即反映
  $("targetPoints").addEventListener("input", updateBAll);
  $("currentRealPoints").addEventListener("input", updateBAll);
  $("currentDeathPoints").addEventListener("input", updateBAll);
  $("mainRank").addEventListener("change", updateBAll);
  $("subRank").addEventListener("change", () => { if (!$("irregularBox").classList.contains("hidden")) updateIrregular(); });

  // イレギュラーON/OFF
  $("toggleIrregular").addEventListener("click", () => {
    $("irregularBox").classList.toggle("hidden");
    updateBAll();
  });

  // イレギュラー入力：即反映
  $("mainCountManual").addEventListener("input", () => {
    if (!$("irregularBox").classList.contains("hidden")) updateIrregular();
  });

})();
</script>
</body>
</html>
